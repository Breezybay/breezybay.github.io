<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Breezy Bay</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2021-07-21T13:01:22.370Z</updated>
  <id>/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Substance Painter - Unity 效果还原的一种方法</title>
    <link href="/2021/05/01/20210501-SubstancePainter_Unity/"/>
    <id>/2021/05/01/20210501-SubstancePainter_Unity/</id>
    <published>2021-04-30T16:00:00.000Z</published>
    <updated>2021-07-21T13:01:22.370Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/ta/meetmat2-title.jpg" alt></p><p>美术经常有这样的困扰，“为什么我在SP里的效果是这样的，进了Unity就变成那样了？”</p><p>对于美术生产来说，不能所见即所得，进引擎的最终效果靠猜，是非常不利于美术创作的。</p><p>另一方面，没有这样的一个与引擎内效果统一的生产环境，也不利于外包的工作。</p><p>所以引擎与生产环境效果的统一，是打通PBR Pipeline的重要一环，对工业化水平的提升是非常有意义的。</p><p>目前网上找到的分享中，大都有这样的困扰，就是由于Unity和SP两边光照环境的区别，很难做到非常一致的效果。</p><p>这里给大家分享一个Unity效果还原到SP的方法，通过将Unity的光照与Shader还原到SP中，基本可以做到两边的效果比较相似。</p><a id="more"></a><h3 id="光照环境"><a href="#光照环境" class="headerlink" title="光照环境"></a>光照环境</h3><p>在SP的Shader中直接写入直接光照来统一两边表现可以比较简单的实现，这里按下不表，主要讲一下怎么把Unity的环境高光挪到SP里。</p><p>SP中是通过对环境进行重要性采样来计算IBL的，而Unity中是根据粗糙度来采样Cubemap，但是这个Cubemap是Unity提前Bake好的。</p><p><img src="/img/ta/sp-baked.jpg" alt><br>Studio 03 的mipmap，在Unity（上）与SP（下）中的对比</p><p>挖了下Unity源码，没有看到具体是怎么Bake的，所以使用了非常暴力的做法，直接把Unity烘焙好的环境球提供给SP，Shader直接采样这个Unity的Cubemap，不再采样SP自己的环境。通过这样的方式，来统一两边的环境光照。</p><h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h3><p>Substance的API文档和自带的几个Shader都是很好的参考对象。</p><p>Shader相对比较直接，把Unity的算法搬过来就好，基本在以下几个地方：</p><p>Internal-DeferredReflections<br>UnityPBSLighting<br>UnityGlobalIllumination<br>UnityStandardBRDF<br>UnityImageBasedLighting</p><p>可以先把half3这些define了，把常用函数也复制过来，抄起来方便很多，这点可以参考nagnae的这篇blog文章。另外这篇文章的最后也准备了懒人包。</p><p>因为是先写了原生Unity 5.6的效果再在那个的基础上还原自己项目的Shader，这里稍微分享下原生Unity SP Shader的片段。</p><p>间接高光部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">half3 IndirectSpecular(LocalVectors vectors, half roughness, half occlusion)</span><br><span class="line">&#123;</span><br><span class="line">    roughness = roughness*(1.7 - 0.7*roughness);</span><br><span class="line"></span><br><span class="line">    half mip = perceptualRoughnessToMipmapLevel(roughness);</span><br><span class="line">    half3 reflUVW = reflect(-vectors.eye, vectors.normal);</span><br><span class="line">    </span><br><span class="line">    half3 env0 = envSampleLODCustom(reflUVW, mip).rgb;</span><br><span class="line"></span><br><span class="line">    return env0 * occlusion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/ta/meetmat2-comparison.jpg" alt><br>写Shader的过程中可以通过对比一些中间结果确定自己没跑偏，上图显示的是mip</p><p>BRDF（连人家的注释都一起抄过来），这里只有高光。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">half3 UNITY_BRDF_PBS(LocalVectors vectors, UnityStandardData data, float oneMinusReflectivity)</span><br><span class="line">&#123;</span><br><span class="line">  half perceptualRoughness = SmoothnessToPerceptualRoughness (data.smoothness);</span><br><span class="line">  half roughness = PerceptualRoughnessToRoughness(perceptualRoughness);</span><br><span class="line"></span><br><span class="line">  vec3 Ln = half3(0, 1, 0);</span><br><span class="line">  vec3 Hn = normalize(Ln + vectors.eye);</span><br><span class="line"></span><br><span class="line">  float nv = saturate(dot(data.normalWorld, vectors.eye));</span><br><span class="line">  float nl = saturate(dot(vectors.normal, Ln));</span><br><span class="line">  float nh = saturate(dot(vectors.normal, Hn));</span><br><span class="line"></span><br><span class="line">  float lv = saturate(dot(Ln, vectors.eye));</span><br><span class="line">  float lh = saturate(dot(Ln, Hn));</span><br><span class="line"></span><br><span class="line">  float vh = saturate(dot(vectors.eye, Hn));</span><br><span class="line"></span><br><span class="line">  half diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;</span><br><span class="line"></span><br><span class="line">  half V = SmithJointGGXVisibilityTerm (nl, nv, roughness);</span><br><span class="line">  half D = GGXTerm (nh, roughness);</span><br><span class="line"></span><br><span class="line">  half specularTerm = V * D * 3.14159265359; // Torrance-Sparrow model, Fresnel is applied later</span><br><span class="line">  // specularTerm * nl can be NaN on Metal in some cases, use max() to make sure it&apos;s a sane value</span><br><span class="line">  specularTerm = max(0, specularTerm * nl);</span><br><span class="line"></span><br><span class="line">  // To provide true Lambert lighting, we need to be able to kill specular completely.</span><br><span class="line">  specularTerm *= any(data.specularColor) ? 1.0 : 0.0;</span><br><span class="line"></span><br><span class="line">  // surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL&gt;0) dH = 1/(roughness^2+1)</span><br><span class="line">  float surfaceReduction = 1.0 / (roughness*roughness + 1.0);</span><br><span class="line"></span><br><span class="line">  half grazingTerm = saturate(data.smoothness + (1 - oneMinusReflectivity));</span><br><span class="line"></span><br><span class="line">  return surfaceReduction * IndirectSpecular(vectors, perceptualRoughness, data.occlusion) * FresnelLerp(data.specularColor, vec3(grazingTerm), nv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>放一个原生Unity配Substance Painter的效果。<br><img src="/img/ta/meetmat2-title-ori.jpg" alt></p><h3 id="写在最后的一些实用小东西"><a href="#写在最后的一些实用小东西" class="headerlink" title="写在最后的一些实用小东西"></a>写在最后的一些实用小东西</h3><h5 id="在SP里刷新Shader"><a href="#在SP里刷新Shader" class="headerlink" title="在SP里刷新Shader"></a>在SP里刷新Shader</h5><p>SP的Custom Shader是不会实时更新效果的，如何在SP里刷新修改后的Shader呢？</p><p>首先在某个位置创建自己的glsl Shader；</p><p>然后将Shader文件拖进SP，在导入设置里选择project项；</p><p><img src="/img/ta/Import Shader to project.jpg" alt></p><p>修改了Shader文件，想要在SP中看到效果的时候，右键Shader选择Reload；</p><p>这个小技巧是参考了<a href="https://qiita.com/harayoki/items/0d9ac27435246cbd0fbd" target="_blank" rel="noopener">harayoki的分享</a>。</p><h5 id="Unity环境球转到Substance的一些细节"><a href="#Unity环境球转到Substance的一些细节" class="headerlink" title="Unity环境球转到Substance的一些细节"></a>Unity环境球转到Substance的一些细节</h5><p>SP不认Cubemap，所以需要做一个转换。</p><p>这个Staff推荐的HDRShop我只试了v1，不太好用。推荐使用ImageViewer这个工具，很方便。</p><h3 id="懒人包"><a href="#懒人包" class="headerlink" title="懒人包"></a>懒人包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">half Pow5 (half x)</span><br><span class="line">&#123;</span><br><span class="line">    return x*x * x*x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half SpecularStrength(half3 specular)</span><br><span class="line">&#123;</span><br><span class="line">    return max (max (specular.r, specular.g), specular.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half perceptualRoughnessToMipmapLevel(half perceptualRoughness)</span><br><span class="line">&#123;</span><br><span class="line">    return perceptualRoughness * MIP_STEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness)</span><br><span class="line">&#123;</span><br><span class="line">    half fd90 = 0.5 + 2 * LdotH * LdotH * perceptualRoughness;</span><br><span class="line">    // Two schlick fresnel term</span><br><span class="line">    half lightScatter   = (1 + (fd90 - 1) * Pow5(1 - NdotL));</span><br><span class="line">    half viewScatter    = (1 + (fd90 - 1) * Pow5(1 - NdotV));</span><br><span class="line"></span><br><span class="line">    return lightScatter * viewScatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half SmithJointGGXVisibilityTerm (half NdotL, half NdotV, half roughness)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    half a = roughness;</span><br><span class="line">    half lambdaV = NdotL * (NdotV * (1 - a) + a);</span><br><span class="line">    half lambdaL = NdotV * (NdotL * (1 - a) + a);</span><br><span class="line"></span><br><span class="line">    return 0.5f / (lambdaV + lambdaL + 1e-5f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half GGXTerm (half NdotH, half roughness)</span><br><span class="line">&#123;</span><br><span class="line">    half a2 = roughness * roughness;</span><br><span class="line">    half d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad</span><br><span class="line">    return 0.31830988618 * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,</span><br><span class="line">                                            // therefore epsilon is smaller than what can be represented by half</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half3 FresnelLerp(half3 F0, half3 F90, half cosA)</span><br><span class="line">&#123;</span><br><span class="line">  half t = Pow5(1 - cosA);   // ala Schlick interpoliation</span><br><span class="line">  return lerp(F0, F90, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half3 DiffuseFromMetallic (half3 albedo, half metallic)</span><br><span class="line">&#123;</span><br><span class="line">    float oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);</span><br><span class="line">    return albedo * oneMinusReflectivity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half3 SpecularFromMetallic (half3 albedo, half metallic)</span><br><span class="line">&#123;</span><br><span class="line">    return lerp (unity_ColorSpaceDielectricSpec.rgb, albedo, metallic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>Substance Docs，Shader API，2021</li><li>Razor Yang，简单聊聊CODM的图形，2021</li><li>harayoki,【SubstancePainter】編集中のシェーダーをすぐさまリロードする, 2019</li><li>nagnae，Substance Painter’s shader for Unity，2018</li><li>月光下的旅行，Substance Painter Shader与UE4移动端渲染效果同步2020</li><li>IanBanks, arma 3 substance shader, 2018</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/ta/meetmat2-title.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;美术经常有这样的困扰，“为什么我在SP里的效果是这样的，进了Unity就变成那样了？”&lt;/p&gt;
&lt;p&gt;对于美术生产来说，不能所见即所得，进引擎的最终效果靠猜，是非常不利于美术创作的。&lt;/p&gt;
&lt;p&gt;另一方面，没有这样的一个与引擎内效果统一的生产环境，也不利于外包的工作。&lt;/p&gt;
&lt;p&gt;所以引擎与生产环境效果的统一，是打通PBR Pipeline的重要一环，对工业化水平的提升是非常有意义的。&lt;/p&gt;
&lt;p&gt;目前网上找到的分享中，大都有这样的困扰，就是由于Unity和SP两边光照环境的区别，很难做到非常一致的效果。&lt;/p&gt;
&lt;p&gt;这里给大家分享一个Unity效果还原到SP的方法，通过将Unity的光照与Shader还原到SP中，基本可以做到两边的效果比较相似。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Unity" scheme="/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>(搬运) Far Cry的火如何燃烧与传播</title>
    <link href="/2021/03/30/20210330-FarCry_Fire%20-%20Copy/"/>
    <id>/2021/03/30/20210330-FarCry_Fire - Copy/</id>
    <published>2021-03-29T16:00:00.000Z</published>
    <updated>2021-09-17T11:49:40.133Z</updated>
    
    <content type="html"><![CDATA[<p>主要是翻译与搬运，原文见参考资料中的链接。</p><p><img src="http://jflevesque.com/wp-content/uploads/2020/01/Far-Cry-3-man-on-fire.jpg" alt></p><h3 id="Far-Cry-2-背景故事"><a href="#Far-Cry-2-背景故事" class="headerlink" title="Far Cry 2 背景故事"></a>Far Cry 2 背景故事</h3><p>当年，育碧蒙特利尔的 初级Gameplay程序员Jean-Francois Lévesque，用了超过一年的时间研究并开发了Far Cry 2的火焰传播功能。以下是他接受采访的部分内容：</p><p>育碧蒙特利尔为什么决定这样一个复杂的，程序化的功能是设计上所需要的？<br>创意总监Clint Hocking在非常早期的时候就想要制造一种新的玩家沉浸。这个设计非常有野心，为了支持这个愿景开发团队需要达到一个功能上的新高度。<br>很少有游戏公司愿意让一个人全职三年就为了开发植被系统，或者让另一个人工作一年半就是为了让火更真实。这就是团队为了达到我们为自己设定的目标所付出的奉献与努力。</p><p>但是火焰功能并不是一开始就这么野心勃勃。</p><a id="more"></a><p>最初技术总监Dominic Guay指派Jean去做火焰传播的时候，Dominic预见到性能会是一个问题。<br>所以他最开始的计划是让火焰仅在小型的预先定义好的10x10m的小块草，以及一些非常小的物体上进行。<br>几周后Jean实现了Dominic想要的功能，于是制作人Louis-Pierre Pharand和Clint飞到巴黎像管理团队展示了Demo。<br>结果巴黎的管理层非常喜欢这个火，他们想要整个Savanna和每一棵树都能着火。因为Jean是个初级并且对这个东西开发起来多复杂没有概念，于是就同意去做了。</p><p>这就是火焰如何成为Far Cry主要特色的故事。</p><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><p><img src="http://jflevesque.com/wp-content/uploads/2020/01/ACell1.jpg" alt><br>Far Cry的火焰传播基于平均分布的网格，对于草使用2D网格，对物体和树使用3D网格。<br>每个格子（cell）都记录了它在世界中的坐标、范围和HP（hitpoints），格子们还有很多其它属性，但是这三条是火焰延烧所必需的。</p><h3 id="点火！怎么放火？"><a href="#点火！怎么放火？" class="headerlink" title="点火！怎么放火？"></a>点火！怎么放火？</h3><p>游戏引擎记录了游戏内的所有伤害（damage），如子弹伤害，爆炸或火焰伤害。当一个游戏实体（game entity）被破坏，它会收到一个事件（event），这个伤害事件包括了伤害值，伤害类型和造成伤害的原因。如果伤害类型是基于火焰的并且该实体是可燃的（flammable），则以下两件事情会发生：</p><ul><li>首先，被伤害的实体的火焰网格（fire grid）会动态的生成。一旦生成，会一直存在。</li><li>第二，我们找到距离伤害源最近的邻接格子，它们会受到伤害，HP会相应减少。<br>当一个格子被火焰伤害并且失去了所有HP，它就着火了</li></ul><p>烧起来之后，这个格子自己就变成了伤害输出者（damager）。它会对周围的格子造成伤害。周围格子HP归零之后，就会起火。这就是火焰传播的方式。<br><img src="http://jflevesque.com/wp-content/uploads/2020/01/2DGridBiggerFire1.jpg" alt><br>最后，格子需要一个有限的持续时间（lifetime），不然它会永远烧下去。它可以看作是为可燃材质设定的能量。比如，一片纸比一块木头的持续时间短。</p><h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>潮湿的雨林 vs 干燥的草地<br>增加雨林格子的HP，它就变得不容易点着，火焰传播会变慢。降低持续时间所以火会变得更快熄灭</p><p>如何创建传播网格<br>草/地：实时创建一个2D的网格并投影到3D地形上。对每个格子判断它是否在水下，或者在石头、房子的下面，这些格子会被关闭并永远不会着火。<br><img src="http://jflevesque.com/wp-content/uploads/2020/01/2DGridDisabled.jpg" alt></p><p>物体：创建一个AABB完全包括物体，平均切分Bounding Box到很多小方块（方块数量取决于物体大小以及性能）。循环监测每个方块并进行碰撞检测，去掉无效的格子。<br><img src="http://jflevesque.com/wp-content/uploads/2020/01/3DGrid.jpg" alt></p><h3 id="风"><a href="#风" class="headerlink" title="风"></a>风</h3><p>风为玩家增加了一层真实性。这里我们很容易会想太多，然后去实现一套非常复杂的系统。<br><img src="http://jflevesque.com/wp-content/uploads/2020/01/1-s2.0-S1540748912001988-gr3.jpg" alt><br>火焰朝风的方向传播的更快，我们对风的方向与邻接格子的方向做一个点乘（dot product），结果越大，那个格子受到的伤害越多。<br><img src="http://jflevesque.com/wp-content/uploads/2020/01/ACellWindEffect1.jpg" alt><br>这一条就可以获得一个很好的朝风的方向传播的钟形火线</p><h3 id="向周围的东西传播以及链式反应"><a href="#向周围的东西传播以及链式反应" class="headerlink" title="向周围的东西传播以及链式反应"></a>向周围的东西传播以及链式反应</h3><p>当一个格子起火，它会发送一个消息 “我着火了然后我得燃烧范围是这些”。这个事件被范围内的其它物体、AI以及其它游戏系统获取。它们分别对这条消息作出反应，AI会吓跑，可燃物受到伤害。<br><img src="http://jflevesque.com/wp-content/uploads/2020/01/2DGridDmgZone.jpg" alt></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h5 id="植发策略（Hair-Transplant-Strategy）"><a href="#植发策略（Hair-Transplant-Strategy）" class="headerlink" title="植发策略（Hair Transplant Strategy）"></a>植发策略（Hair Transplant Strategy）</h5><p>在理想情况下，我们可以跑动很多的粒子发射器，我们可以在屏幕上显示大量的粒子。<br>不幸的是，在现实中这些数量其实都非常低。<br>我们需要把发射器放到最需要的地方，所以我们采用植发策略（Hair Transplant Strategy）！<br>在Far Cry 2中，火焰粒子发射器被不停的瞬移，最常见的是从相机远处移到相机前面。<br>并且近距离的时候发射器的密度更高，越远越稀疏。你可以把这想成一种火焰LOD。<br>如果我们需要更多发射器但是没有预算了，我们就增大粒子尺寸让它们填充更多屏幕空间。<br>使用这个策略，我们可以模拟几米宽的野火，用相对少量的粒子发射器</p><p><img src="http://jflevesque.com/wp-content/uploads/2020/01/farc2.jpg" alt></p><h5 id="事件管线"><a href="#事件管线" class="headerlink" title="事件管线"></a>事件管线</h5><p>当你有上千个格子在燃烧并向世界广播事件时，你的CPU可能就快卡死了。<br>解决方法是重组格子们为AABB组，这些组会动态的合并、分裂、变形，来跟随火焰的变化。<br>于是事件变成由AABB发送，而不是每个格子。另外事件还可以分帧发送来避免性能尖峰。</p><h5 id="可控性"><a href="#可控性" class="headerlink" title="可控性"></a>可控性</h5><p>如果不限制火焰传播，那么火焰会</p><p>烧毁全图杀死所有NPC<br>用几千个网格和发射器把内存挤爆<br>把帧率卡成PPT<br>以上所有<br>有很多方式可以解决个问题，我得方式可能不是最优解。但是我试图找到最简单可行的方案。<br>设计一个闭环系统为火焰分配传播点数（Spreading points）并且在传播的时候消耗点数。<br>举个例子，一个玩家扔了一瓶莫洛托夫到干草地上。这瓶莫洛托夫给了那小片草60点传播点数。<br>火焰燃烧草的时候，需要8点传播点数，于是这个火在结束前可以传播7个格子。<br>如果玩家扔了2瓶莫洛托夫，那个草片会有120点，使它能够消耗15个格子。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>GDC Speaker Q&amp;A, <a href="https://gdconf.com/news/qa-remi-quenin-discusses-data-pipeline-farcry-5" target="_blank" rel="noopener">Speaker Q&amp;A: Ubisoft’s Remi Quenin Discusses The Data Pipeline Of FarCry 5</a>, GDC 2017</li><li>M Müller, <a href="https://hdms.bsz-bw.de/frontdoor/index/index/docId/6419" target="_blank" rel="noopener">Developing a Fire Propagation System for a Massively Multiplayer Online Game</a>, Masterarbeit 2018</li><li>Jean-Francois Levesque, <a href="http://jflevesque.com/2012/12/06/far-cry-how-the-fire-burns-and-spreads/" target="_blank" rel="noopener">Far Cry : How the Fire Burns and Spreads</a>, 2012.</li><li>Chris Remo，<a href="https://www.gamasutra.com/view/news/111851/Interview_How_Far_Cry_2s_Fire_Fuels_Spreads.php" target="_blank" rel="noopener">Interview: How Far Cry 2’s Fire Fuels, Spreads</a>，2008</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是翻译与搬运，原文见参考资料中的链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jflevesque.com/wp-content/uploads/2020/01/Far-Cry-3-man-on-fire.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;Far-Cry-2-背景故事&quot;&gt;&lt;a href=&quot;#Far-Cry-2-背景故事&quot; class=&quot;headerlink&quot; title=&quot;Far Cry 2 背景故事&quot;&gt;&lt;/a&gt;Far Cry 2 背景故事&lt;/h3&gt;&lt;p&gt;当年，育碧蒙特利尔的 初级Gameplay程序员Jean-Francois Lévesque，用了超过一年的时间研究并开发了Far Cry 2的火焰传播功能。以下是他接受采访的部分内容：&lt;/p&gt;
&lt;p&gt;育碧蒙特利尔为什么决定这样一个复杂的，程序化的功能是设计上所需要的？&lt;br&gt;创意总监Clint Hocking在非常早期的时候就想要制造一种新的玩家沉浸。这个设计非常有野心，为了支持这个愿景开发团队需要达到一个功能上的新高度。&lt;br&gt;很少有游戏公司愿意让一个人全职三年就为了开发植被系统，或者让另一个人工作一年半就是为了让火更真实。这就是团队为了达到我们为自己设定的目标所付出的奉献与努力。&lt;/p&gt;
&lt;p&gt;但是火焰功能并不是一开始就这么野心勃勃。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
  </entry>
  
  <entry>
    <title>工程目录结构 Project Folder Structure</title>
    <link href="/2020/08/09/20200809-ProjectFolderStructure/"/>
    <id>/2020/08/09/20200809-ProjectFolderStructure/</id>
    <published>2020-08-08T16:00:00.000Z</published>
    <updated>2021-09-29T12:34:41.539Z</updated>
    
    <content type="html"><![CDATA[<p>游戏工程的目录结构不是一个非常显性并且被重视的事情，但对于具备一定规模的项目，不合理的工程目录结构会导致一些问题，比如：</p><ul><li>场景间耦合，A场景引用了存在B场景的资源</li><li>迭代速度慢，难以持续集成，资源打包时间变长（须打包大目录下的较大Bundle）</li><li>整体资源量失控，更新包数据量变大</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>随便猜的一些目录结构的例子，不代表实际情况</p><table><thead><tr><th style="text-align:center">好的</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">不太好的</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/img/pipeline/folderStructure_Borderlands3.png" alt></td><td style="text-align:center"><img src="/img/pipeline/folderStructure_ROE.png" alt></td><td style="text-align:center"><img src="/img/pipeline/folderStructure_Valorant.png" alt></td><td style="text-align:center"><img src="/img/pipeline/folderStructure_Fortnite.png" alt></td><td style="text-align:center"><img src="/img/pipeline/folderStructure_PUBG.png" alt></td></tr></tbody></table><a id="more"></a><h3 id="一个方案"><a href="#一个方案" class="headerlink" title="一个方案"></a>一个方案</h3><p><img src="/img/pipeline/folderStructure_SharedRes3.png" alt></p><ul><li><strong>通用资源库</strong>，如果一个资源被多个场景引用，该资源应该位于通用资源库中<ul><li>可以设置一个<strong>通用材质库</strong>，类似调色板</li></ul></li><li><strong>资源素材位置统一</strong>，同一<strong>组</strong>（如Bricks）/ 同一<strong>个</strong>（Brick001A）资源的相关素材（网格、材制、贴图）放在同一个目录下<ul><li>按同一<strong>组</strong>资源进行管理，可以更方便管理有局部共用资源的情况，如某场景的共用贴图和材质，可以在本地目录中共用，不需要放入通用资源库</li><li>按同一<strong>个</strong>资源进行管理，可以以更小的单位分离资源，当变体(Brick001A)与原型(Brick001)有共用素材的时候，仅关联原型的素材</li></ul></li><li><strong>公共资源</strong>修改流程/权限。明确一个修改是修改地图，还是修改（公共）资源；如果是修改公共资源，需要先确认该资源修改会造成什么影响，被哪些场景使用，是应该修改，还是应该新增一个资源<ul><li>确须修改某个地图内的公共资源，但又不能修改其它受影响的地图的情况，可以考虑新增资源，如新增某一资源的v2、v3版本</li></ul></li><li>场景地图<strong>分工程</strong>，<strong>分版本库</strong>，仅关联本地图实际用到的通用资源目录</li><li>地形资源按照<strong>生态</strong>进行分类</li></ul><table><thead><tr><th style="text-align:center">通用材质库</th><th style="text-align:center">通用预制库</th><th style="text-align:center">生态分类</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/img/pipeline/folderStructure_SharedMaterials.png" alt></td><td style="text-align:center"><img src="/img/pipeline/folderStructure_SharedProps.png" alt></td><td style="text-align:center"><img src="/img/pipeline/folderStructure_Biome.png" alt></td></tr></tbody></table><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ul><li>美术能够<strong>持续集成</strong></li><li>资源<strong>打包时间</strong>缩短</li><li><strong>更新包</strong>数据量变小（通常仅需更新该资源本身）</li><li>整体<strong>资源量</strong>得到控制</li><li>场景工程可以<strong>独立开发</strong>（可以整包某个单独场景）</li><li><strong>迭代</strong>效率提升（更轻量灵活，减少冲突）</li></ul><p>更合理的目录结构，优化打包及加载性能<br>美术成本更可控：内部研发，核对策划需求，资产控制都更可控</p><h5 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h5><p>如果是在项目中期进行结构变更，可能面临以下风险：</p><ul><li>需要一段较长时间（1~2个月）的修复期</li><li>以目录路径为前提的脚本工具等需要更新</li><li>美术需要时间熟悉适应新的目录结构及相关规范</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;游戏工程的目录结构不是一个非常显性并且被重视的事情，但对于具备一定规模的项目，不合理的工程目录结构会导致一些问题，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;场景间耦合，A场景引用了存在B场景的资源&lt;/li&gt;
&lt;li&gt;迭代速度慢，难以持续集成，资源打包时间变长（须打包大目录下的较大Bundle）&lt;/li&gt;
&lt;li&gt;整体资源量失控，更新包数据量变大&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;p&gt;随便猜的一些目录结构的例子，不代表实际情况&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;好的&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;不太好的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/img/pipeline/folderStructure_Borderlands3.png&quot; alt&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/img/pipeline/folderStructure_ROE.png&quot; alt&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/img/pipeline/folderStructure_Valorant.png&quot; alt&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/img/pipeline/folderStructure_Fortnite.png&quot; alt&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/img/pipeline/folderStructure_PUBG.png&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Unity" scheme="/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity 基于图层的非破坏性（Non-Destructive Layer-Based ）地形工具</title>
    <link href="/2020/05/01/20200501-NonDestructive_LayerBased_Terrain/"/>
    <id>/2020/05/01/20200501-NonDestructive_LayerBased_Terrain/</id>
    <published>2020-04-30T16:00:00.000Z</published>
    <updated>2021-09-17T11:50:20.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/terrain/LayeredTerrain.gif" alt></p><a id="more"></a><h3 id="定义-What"><a href="#定义-What" class="headerlink" title="定义 (What)"></a>定义 (What)</h3><p>A non-destructive workflow means you can go backwards at any time.<br>一个非破坏性的工作流意味着你可以在任何时候回退。</p><p>A good analogy is layers in photoshop - we write information into these layers instead of the terrain, and then combine those layers of data into one final output.<br>一个很好的类比是Photoshop里的图层 - 我们把信息写入这些图层而不是地形，然后合并这些图层的数据到最终输出。</p><h3 id="原因-Why"><a href="#原因-Why" class="headerlink" title="原因 (Why)"></a>原因 (Why)</h3><p>使用基于图层的工作流提供可以回退，融合，覆盖的操作。增加创作力，提升工作效率。</p><h3 id="方案-How"><a href="#方案-How" class="headerlink" title="方案 (How)"></a>方案 (How)</h3><p>参考Unreal <a href="http://confluence.wd.com/pages/viewpage.action?pageId=23155996" target="_blank" rel="noopener">非破坏性地形图层和样条 Non-Destructive Landscape Layers and Splines</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/terrain/LayeredTerrain.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Unity" scheme="/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Terrain Tiling &amp; Stitching</title>
    <link href="/2020/04/18/20200418-TerrainTiling/"/>
    <id>/2020/04/18/20200418-TerrainTiling/</id>
    <published>2020-04-17T16:00:00.000Z</published>
    <updated>2021-09-17T12:01:23.251Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">Micro-Macro Variations Lerp with Perlin Noise</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/img/terrain/Micro-Macro Variations Lerp with Perlin Noise.gif" alt></td></tr></tbody></table><a id="more"></a><table><thead><tr><th style="text-align:center">Micro Variation</th><th style="text-align:center"></th><th style="text-align:center">Macro Variation</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/img/terrain/Micro Variation.gif" alt></td><td style="text-align:center">-</td><td style="text-align:center"><img src="/img/terrain/Macro Variation.gif" alt></td></tr></tbody></table><table><thead><tr><th style="text-align:center">Unity Built-In</th><th style="text-align:center"></th><th style="text-align:center">Micro-Macro Variations with Noise</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/img/terrain/TerrainTiling1.jpg" alt></td><td style="text-align:center">-</td><td style="text-align:center"><img src="/img/terrain/TerrainTiling2.jpg" alt></td></tr></tbody></table><p><img src="/img/terrain/Rock.gif" alt></p><p>在野外需要大面积绘制地形的情况下，地形渲染消耗 + 0.1~0.2ms @750Ti</p><h3 id="Terrain-Stitching"><a href="#Terrain-Stitching" class="headerlink" title="Terrain Stitching"></a>Terrain Stitching</h3><p><a href="https://docs.unity3d.com/ScriptReference/Terrain.SetNeighbors.html" target="_blank" rel="noopener">Unity - Scripting API: Terrain.SetNeighbors</a></p><table><thead><tr><th style="text-align:center">Before</th><th style="text-align:center"></th><th style="text-align:center">After</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/img/terrain/stitching-1.png" alt></td><td style="text-align:center">-</td><td style="text-align:center"><img src="/img/terrain/stitching-2.png" alt></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Micro-Macro Variations Lerp with Perlin Noise&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/img/terrain/Micro-Macro Variations Lerp with Perlin Noise.gif&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Unity" scheme="/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Simplygon HLOD for Unity</title>
    <link href="/2020/03/29/20200329-Simplygon/"/>
    <id>/2020/03/29/20200329-Simplygon/</id>
    <published>2020-03-28T16:00:00.000Z</published>
    <updated>2020-08-02T06:39:02.133Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p><a href="https://simplygon.com/Downloads" target="_blank" rel="noopener">Simplygon SDK</a>，Simplygon SDK 需要 Win10。<br>Unity中导入Simplygon Plugin，需要Unity版本5.5以上，目前Simplygon官方不维护Unity，需要自己处理。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>合并方法可以参考Unity官方的AutoLOD：<a href="https://github.com/Unity-Technologies/AutoLOD/blob/master/Scripts/Editor/MeshSimplifiers/SimplygonMeshSimplifier.cs" target="_blank" rel="noopener">SimplygonMeshSimplifier</a></p><p>使用RemeshingProcessor；<br>在RemeshingSettings中，设置OnScreenSize，HardEdgeAngleInRadians；<br>在MappingImageSettings中，设置TexCoordGeneratorType，UseFullRetexturing，Width，Height；</p><p>执行过程中，Simplygon Plugin在某些情况下会报错（比如模型Material数量少于SubMesh数量），可以定位报错位置并使用<a href="https://github.com/0xd4d/dnSpy" target="_blank" rel="noopener">dnSpy</a>对其进行反编译后修复。</p><p>生成Simplygon资源过程中的性能瓶颈主要在于从Unity上传资源到Simplygon及合并后的资源Download到Unity。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://simplygon.com/Downloads&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Unity" scheme="/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>ComputeShader Noise</title>
    <link href="/2019/10/06/20191006-TerrainDetailUtil/"/>
    <id>/2019/10/06/20191006-TerrainDetailUtil/</id>
    <published>2019-10-05T16:00:00.000Z</published>
    <updated>2020-08-02T07:52:05.494Z</updated>
    
    <content type="html"><![CDATA[<p>可以用 <a href="https://github.com/keijiro" target="_blank" rel="noopener">Keijiro Takahashi</a>的<a href="https://github.com/keijiro/NoiseShader" target="_blank" rel="noopener">Noise Shader Library for Unity</a></p><h4 id="ComputeShader"><a href="#ComputeShader" class="headerlink" title="ComputeShader"></a>ComputeShader</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask = Perlin( xy / NoiseScale * Resolution )</span><br><span class="line"></span><br><span class="line">Final[id] = min( Final[id] * mask * Offset, Cap);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以用 &lt;a href=&quot;https://github.com/keijiro&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Keijiro Takahashi&lt;/a&gt;的&lt;a href=&quot;https://github.com/keijiro/NoiseSh
      
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Unity" scheme="/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>美术用简单性能讲解 Explanation of performance for Artists</title>
    <link href="/2019/10/01/20191001-Performance4Artists/"/>
    <id>/2019/10/01/20191001-Performance4Artists/</id>
    <published>2019-09-30T16:00:00.000Z</published>
    <updated>2021-09-19T08:09:29.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="贴图对性能的影响"><a href="#贴图对性能的影响" class="headerlink" title="贴图对性能的影响"></a>贴图对性能的影响</h3><p><img src="/img/performance/textureRAM.png" alt></p><a id="more"></a><ul><li>CPU：所有载入的物体，CPU都要管理，并且告诉GPU哪些要绘制，给GPU准备好相应的资源</li><li>内存：所有场景内载入的资源都要进内存</li><li>GPU：画东西的</li><li>显存带宽：去往显存的路。当显存装不下当前绘制所需的所有资源时，就会每帧都可能发生需要去显存的东西太多，这时候就会堵，可能导致帧率大幅下降（比如70-&gt;20）</li><li>显存：GPU储存绘制相关资源的地方，比如贴图，Mesh，Shader</li><li>Tex Cache：GPU画每个Drawcall时拿在手头的资源，画东西的时候用手上的材料最快，如果手上没有，就得去显存找，这样就慢了。</li><li>Shader：怎么画</li></ul><h3 id="为什么要合理设置LOD"><a href="#为什么要合理设置LOD" class="headerlink" title="为什么要合理设置LOD"></a>为什么要合理设置LOD</h3><h4 id="辛苦的GPU"><a href="#辛苦的GPU" class="headerlink" title="辛苦的GPU"></a>辛苦的GPU</h4><p>GPU就像一个画家，每一帧，他都要画满一屏的画。</p><p>为了绘制一个物体，他要先把箱子的网格、贴图等等拿在手上，就像准备颜料盘和画笔一样。（如果需要拿的东西太多，一次拿不下了，那就只能先拿一部分画一画，再拿起另一部分画一画，极大降低绘制速度）</p><p>每一个物体，他都要这样做。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"><img src="/img/performance/lod1.png" alt></td><td style="text-align:center">-</td><td style="text-align:center"><img src="/img/performance/lod2.png" alt></td></tr></tbody></table><p>所以，如果场景里有成百上千个实际上不需要绘制的物体，我们应该把它们从需要绘制的物体列表中去掉，否则GPU就要每帧每帧都付出成百上千次不必要的辛苦。</p><p>如果一个离得很远的物体，我们应该把它的精度降低到适合屏幕的程度，否则GPU就要每帧付出不必要的辛苦。</p><p>不止在绘制这个物体的色彩时，在绘制阴影、ZPrePass阶段也要一个一个全部来一遍</p><h5 id="想一想"><a href="#想一想" class="headerlink" title="想一想"></a>想一想</h5><p>要维持单位面积的三角面密度（相同屏幕面积内的三角面数一致），如果LOD1的面数是LOD0的50%，LOD0的切换高度是100%，问：LOD1的切换高度是多少？</p><p><img src="/img/performance/lod3.png" alt><br>答案：70%</p><h4 id="辛苦的CPU"><a href="#辛苦的CPU" class="headerlink" title="辛苦的CPU"></a>辛苦的CPU</h4><p>每一帧，CPU都要把需要GPU画出来的东西整理好，一个一个交给GPU。</p><p>如果有很多东西是实际上并不需要画出来的，CPU就要每帧都付出不必要的辛苦。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;贴图对性能的影响&quot;&gt;&lt;a href=&quot;#贴图对性能的影响&quot; class=&quot;headerlink&quot; title=&quot;贴图对性能的影响&quot;&gt;&lt;/a&gt;贴图对性能的影响&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/img/performance/textureRAM.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Graphics" scheme="/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Resize Textures with MSPaint Algorithm via Postprocess</title>
    <link href="/2019/09/15/20190915-PostprocessMSPaint/"/>
    <id>/2019/09/15/20190915-PostprocessMSPaint/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-10-20T09:01:23.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Example-2048-gt-1024"><a href="#Example-2048-gt-1024" class="headerlink" title="Example (2048 -&gt; 1024)"></a>Example (2048 -&gt; 1024)</h3><table><thead><tr><th style="text-align:center">Unity Built-In (Unity自带)</th><th style="text-align:center"></th><th style="text-align:center">MSPaint Kernel（后处理加入画图锐化）</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/img/graphics/MSPaint_UnityBuiltIn.jpg" alt></td><td style="text-align:center">-</td><td style="text-align:center"><img src="/img/graphics/MSPaint_MSPaint.jpg" alt></td></tr></tbody></table><p>MSPaint provides better resize results as stated in <a href="https://computergraphics.stackexchange.com/questions/2246/which-interpolation-algorithm-does-ms-paint-on-windows-7-use-for-image-rescaling" target="_blank" rel="noopener">Which interpolation algorithm does MS Paint on Windows 7 use for image rescaling?</a></p><a id="more"></a><p>Source: <a href="https://stackoverflow.com/a/48855445" target="_blank" rel="noopener">skenera’s answer</a></p><p>MSPaint uses bilinear interpolation then sharpens the image with a convolution kernel:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.0, -0.125, 0.0</span><br><span class="line"></span><br><span class="line">-0.125, 1.5, -0.125</span><br><span class="line"></span><br><span class="line">0.0, -0.125, 0.0</span><br></pre></td></tr></table></figure></p><p>For our current project we need to batch resize using this algorithm.</p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p><a href="https://docs.unity3d.com/ScriptReference/AssetPostprocessor.OnPostprocessTexture.html" target="_blank" rel="noopener">AssetPostprocessor.OnPostprocessTexture(Texture2D)</a></p><p>The actual kernel used:</p><p>new float[3]{ 0.0f, -0.25f, 0.0f },<br>new float[3]{ -0.25f, 2f, -0.25f },<br>new float[3]{ 0.0f, -0.25f, 0.0f }</p><h3 id="ImageMagick"><a href="#ImageMagick" class="headerlink" title="ImageMagick"></a>ImageMagick</h3><p>An alternative approach would be compressing source texture files with ImageMagick.<br>However it is only useful in some cases and is not recommended, compare to postprocess approach.</p><p>ImageMagick Command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magick image.png -scale 512 -morphology Convolve &quot;3x3: 0.0, -0.125, 0.0 -0.125, 1.5, -0.125 0.0, -0.125, 0.0&quot; image_resized.png</span><br></pre></td></tr></table></figure></p><p>Download <a href="https://imagemagick.org/index.php" target="_blank" rel="noopener">ImageMagick</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Example-2048-gt-1024&quot;&gt;&lt;a href=&quot;#Example-2048-gt-1024&quot; class=&quot;headerlink&quot; title=&quot;Example (2048 -&amp;gt; 1024)&quot;&gt;&lt;/a&gt;Example (2048 -&amp;gt; 1024)&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Unity Built-In (Unity自带)&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;MSPaint Kernel（后处理加入画图锐化）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/img/graphics/MSPaint_UnityBuiltIn.jpg&quot; alt&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/img/graphics/MSPaint_MSPaint.jpg&quot; alt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MSPaint provides better resize results as stated in &lt;a href=&quot;https://computergraphics.stackexchange.com/questions/2246/which-interpolation-algorithm-does-ms-paint-on-windows-7-use-for-image-rescaling&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Which interpolation algorithm does MS Paint on Windows 7 use for image rescaling?&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Graphics" scheme="/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Texel Density View Mode</title>
    <link href="/2019/08/18/20190818-TexelDensity/"/>
    <id>/2019/08/18/20190818-TexelDensity/</id>
    <published>2019-08-17T16:00:00.000Z</published>
    <updated>2021-09-01T01:52:51.343Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://80.lv/articles/textel-density-tutorial/" target="_blank" rel="noopener">Figuring out Textel Density - 80 Level</a></p><h2 id="Texel-Density-View-Mode"><a href="#Texel-Density-View-Mode" class="headerlink" title="Texel Density View Mode"></a>Texel Density View Mode</h2><!--| | | ||:------------:|:------------:|:------------:|| ![](/img/graphics/TexelDensityViewMode1.jpg) | - |  ![](/img/graphics/TexelDensityViewMode2.jpg) |--><p><img src="/img/graphics/TexelDensityViewMode1.jpg" alt></p><a id="more"></a><h2 id="关于TD"><a href="#关于TD" class="headerlink" title="关于TD"></a>关于TD</h2><h3 id="Texel-Density-Mesh（UV）上每单位的像素数"><a href="#Texel-Density-Mesh（UV）上每单位的像素数" class="headerlink" title="Texel Density: Mesh（UV）上每单位的像素数"></a>Texel Density: Mesh（UV）上每单位的像素数</h3><p>翻译：</p><ul><li>Texel密度（Autodesk, MODO）</li><li>纹理密度</li><li>像素密度（Valve XSI）</li><li>贴图密度（Unreal UDK）</li><li>纹素密度（《游戏引擎架构》中英词汇索引表）</li></ul><p>简称<strong>TD</strong></p><p>Pixel：屏幕上的最小单位<br>Texel：贴图上的最小单位<br>一个Pixel上有多个texel（缩小）<br>一个texel覆盖多个Pixel（放大）</p><p>正确的密度: 同类素材有一致的TD</p><h3 id="最优做法"><a href="#最优做法" class="headerlink" title="最优做法"></a>最优做法</h3><p>确定游戏类型/环境（第一人称视角，第三人称视角，侧视相机视角等）</p><p>素材分类：可以出现在玩家面前的，背景素材，远景</p><p>通过一些测试确定各个分类的最佳TD</p><p>确定在模型UV上执行这些TD的方式</p><p>确保各个分类内的TD始终保持一致</p><h3 id="如何确定游戏的TD"><a href="#如何确定游戏的TD" class="headerlink" title="如何确定游戏的TD"></a>如何确定游戏的TD</h3><p>有两个主要因素决定贴图大小：</p><ul><li>物体在屏幕上的大小</li><li>内存/显存预算</li></ul><p>理想状态下我们希望Texel和屏幕Pixel尽量一致，<br>但现实中我们只能尽力做到接近。</p><h5 id="第一人称视角-1024-px-m"><a href="#第一人称视角-1024-px-m" class="headerlink" title="第一人称视角 (1024 px/m)"></a>第一人称视角 (1024 px/m)</h5><p>通常TD较高，武器、手有更高TD</p><h5 id="第三人称视角-512-px-m"><a href="#第三人称视角-512-px-m" class="headerlink" title="第三人称视角 (512 px/m)"></a>第三人称视角 (512 px/m)</h5><p>通常不会很接近环境物体，而距离角色较近，所以环境一般为512px每米，而角色略高</p><h5 id="战略视角-128-256-px-m"><a href="#战略视角-128-256-px-m" class="headerlink" title="战略视角 (128-256 px/m)"></a>战略视角 (128-256 px/m)</h5><p>战略视角：总是距离较远，所以不需要高密度</p><h5 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h5><ul><li>TP角色和FP武器离相机较近，TD可以比环境高</li><li>通常角色的脸有相对高的TD，因为玩家爱看脸</li><li>不容易接近的地方可以有较低TD（天空盒，背景，车底部……）</li></ul><h3 id="素材分类"><a href="#素材分类" class="headerlink" title="素材分类"></a>素材分类</h3><p>例如，环境可以分为三类：</p><ul><li>近景/可玩区</li><li>中景/远处物体</li><li>背景物体</li></ul><h3 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h3><p>Maya，Max等都有相应的成熟工具</p><h2 id="Geometry-Shader"><a href="#Geometry-Shader" class="headerlink" title="Geometry Shader"></a>Geometry Shader</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geom</span><span class="params">(triangle v2g input[<span class="number">3</span>], inout TriangleStream&lt;g2f&gt; triStream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算三角面在世界空间面积</span></span><br><span class="line"><span class="keyword">float</span> wArea = <span class="built_in">abs</span>(length(cross(abw, acw)));</span><br><span class="line"></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"><span class="comment">// 像素数</span></span><br><span class="line"><span class="keyword">float</span> texArea = _MainTex_TexelSize.z * _MainTex_TexelSize.w;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UV面积</span></span><br><span class="line"><span class="keyword">float</span> uvArea = <span class="built_in">abs</span>(length(cross(ab, ac)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三角形UV上的像素数</span></span><br><span class="line"><span class="keyword">float</span> uvPixels = texArea * uvArea;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到TD</span></span><br><span class="line"><span class="keyword">float</span> td = <span class="built_in">sqrt</span>(uvPixels / wArea);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行着色</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://80.lv/articles/textel-density-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Figuring out Textel Density - 80 Level&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Texel-Density-View-Mode&quot;&gt;&lt;a href=&quot;#Texel-Density-View-Mode&quot; class=&quot;headerlink&quot; title=&quot;Texel Density View Mode&quot;&gt;&lt;/a&gt;Texel Density View Mode&lt;/h2&gt;&lt;!--
| | | |
|:------------:|:------------:|:------------:|
| ![](/img/graphics/TexelDensityViewMode1.jpg) | - |  ![](/img/graphics/TexelDensityViewMode2.jpg) |
--&gt;
&lt;p&gt;&lt;img src=&quot;/img/graphics/TexelDensityViewMode1.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Graphics" scheme="/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>PBR 贴图制作准则</title>
    <link href="/2019/08/17/20190817-PBRTextureGuideline/"/>
    <id>/2019/08/17/20190817-PBRTextureGuideline/</id>
    <published>2019-08-16T16:00:00.000Z</published>
    <updated>2020-01-07T08:24:56.076Z</updated>
    
    <content type="html"><![CDATA[<!-- ![](https://cdn.allegorithmic.com/images/academy/02bad626-27f5-4606-9908-473d67f816b8) --><h2 id="Metal-Roughness-Workflow-总结"><a href="#Metal-Roughness-Workflow-总结" class="headerlink" title="Metal / Roughness Workflow 总结"></a>Metal / Roughness Workflow 总结</h2><h4 id="纯金属-Metallic-gt-235"><a href="#纯金属-Metallic-gt-235" class="headerlink" title="纯金属  (Metallic &gt; 235)"></a>纯金属  (Metallic &gt; 235)</h4><ul><li>BaseColor上的值是金属的反射值，应当有 70-100%，或者说 180-255 sRGB</li><li>如果你得到某个金属素材，发现它的Base Color很黑，它可能是Specular/Glossiness工作流<br>hexo<h4 id="介电质-绝缘体："><a href="#介电质-绝缘体：" class="headerlink" title="介电质/绝缘体："></a>介电质/绝缘体：</h4></li><li>BaseColor暗部<strong>不应低于30-50 sRGB</strong>, 亮部<strong>不应高于 240 sRGB</strong></li></ul><p>符合PBR规则可以使素材<strong>在任何光照条件下都有合理的表现</strong></p><ul><li>注意,不等于不符合规则的贴图一定看起来不好（在特定光照下有可能看起也合理）</li></ul><p>根据以上原则，制作一个批量排查工具<br><img src="/img/graphics/pbrCheck.jpg" alt></p><a id="more"></a><p>Substance Painter 用PBR检查工具: <a href="https://share.substance3d.com/libraries/824The" target="_blank" rel="noopener">PBR Validate</a><br><img src="https://share.substance3d.com/libraries/824The" alt></p><p>Substance Disigner 可以使用 PBR Metal/Roughness Validate Node<br>位置在Material Filters &gt; PBR Utilities<br><img src="https://cdn.allegorithmic.com/images/academy/bb52362f-6370-4f89-a2f4-633f59868c90" alt></p><p>Source: <a href="https://academy.substance3d.com/courses/the-pbr-guide-part-2" target="_blank" rel="noopener">Practical Guidelines For Creating PBR Textures</a><br>官方中文版：<a href="https://academy.substance3d.com/courses/the-pbr-guide-part2-zh" target="_blank" rel="noopener">创建PBR纹理实用指南</a><br><!--Two most common workflows, which are metal/roughness and specular/glossiness![](https://cdn.allegorithmic.com/images/academy/5fc12cd8-9467-4062-b609-507788d0cbc3)--></p><h2 id="Metal-Roughness-Workflow"><a href="#Metal-Roughness-Workflow" class="headerlink" title="Metal / Roughness Workflow"></a>Metal / Roughness Workflow</h2><h3 id="Dielectric-介电质-绝缘体-F0"><a href="#Dielectric-介电质-绝缘体-F0" class="headerlink" title="Dielectric (介电质/绝缘体) F0"></a>Dielectric (介电质/绝缘体) F0</h3><p>普通绝缘体的 <em>F0</em> 通常设置为 0.04 (linear) 4% 反射。在金属度/粗糙度工作流中，该数值是hardcode在Shader中的。<br>某些金/粗实现中，比如 <em>Substance toolset</em> 和 <em>Unreal Engine 4</em>，提供了Specular控制，使美术可以对绝缘体的 <em>F0</em> 常量进行改变。在Substance中，该输出被标记为 “specularLevel” 并且由一个 texture sampler 提供给shader。如下图，它提供了0.0-0.08的范围。该范围在shader中被映射到0.0～1.0，其中 0.5 对应 4% 反射率。</p><p><img src="https://cdn.allegorithmic.com/images/academy/c16e1e22-42b2-4f5a-af0d-f28b080d325f" alt></p><!--more--><h3 id="基础色-Base-Color-RGB-sRGB"><a href="#基础色-Base-Color-RGB-sRGB" class="headerlink" title="基础色 Base Color (RGB - sRGB)"></a>基础色 Base Color (RGB - sRGB)</h3><p><img src="https://cdn.allegorithmic.com/images/academy/21d2a547-9f5b-4ab2-96b3-deedfd67815f" alt></p><p>Base Color是一张RGB贴图，可以有两种信息：</p><ul><li>绝缘体的漫反射颜色(diffuse reflected color)</li><li>金属反射值</li></ul><p>颜色代表了绝缘体反射的波长，而当一块区域是金属时，金属反射值生效</p><h4 id="制作准则"><a href="#制作准则" class="headerlink" title="制作准则"></a><em>制作准则</em></h4><p>基础色(Base Color)可以被想成一张在色调上很”平”的图。就是说，它的对比度比传统diffuse贴图要低。在这张图上不建议出现过亮或过暗的地方。物体在色调上会比我们通常印象中的要更明亮。</p><p>就亮度范围来说，我们基本上指绝缘体。在下图中，你可以看到脏迹的数值低于正确亮度范围。对暗部来说，<strong>不应低于30-50 sRGB</strong>。暗部数值宽松的说应该大于30，严格地说大于50。对亮部来说，<strong>不应高于 240 sRGB</strong>。<br><img src="https://cdn.allegorithmic.com/images/academy/86a711f0-2e07-4109-9027-33a21ce3d51a" alt></p><p>我们说过base color包含绝缘体表面反射光的信息，所以它不应包含像AO这样的光照信息。可以有一些例外，比如细微的遮蔽（当shader无法仅仅通过ao来体现这一精度的细节时），如下图。<br><img src="https://cdn.allegorithmic.com/images/academy/1e92ba2c-d8b0-476d-ae3c-34c133e16b7d" alt></p><p>金属的反射值应当从现实测量数值中获取。这些数值应当在 <strong>70-100% specular</strong>左右，对应<strong>sRGB范围在 180-255</strong>。</p><p>Sébastien Lagarde的图表是个很好的资源(DONTNOD Physically based rendering chart for Unreal Engine 4](<a href="https://seblagarde.wordpress.com/2014/04/14/dontnod-physically-based-rendering-chart-for-unreal-engine-4/)" target="_blank" rel="noopener">https://seblagarde.wordpress.com/2014/04/14/dontnod-physically-based-rendering-chart-for-unreal-engine-4/)</a>)</p><p><strong>金属的反射值应当从现实测量数值中获取</strong></p><ul><li>颜色代表非金属材质的Albedo，与金属材质的反射值</li><li>基础色(Base color)应该避免包含光照信息，除了微遮蔽(micro-occlusion)</li><li>暗部应该不低于 30 sRGB(宽松下限) 到 50 sRGB(严格下限)</li><li>亮部不应高于240 sRGB</li><li>纯金属的反射很高，在70%-100%，对应 180-255 SRGB</li></ul><p>在接下来的金属段落中你会读到，基础色(base color)包含了金属反射值，如果尘土或锈迹被加在基础色上。会导致该处的金属反射值降低到不可被认定是纯金属的范围。</p><p>金属度贴图(Metallic map)必须考虑尘土和锈迹的情况，这些地方的金属度必须降低以体现这些地方不再被认定为是纯金属。在下图中你可以看到在金属度贴图中锈蚀的地方被当作绝缘体设置成黑色。尘土的地方也设置成了灰色。所以考虑到比如尘土的这种情况，金属度贴图并不总是非黑即白的0/1贴图。<br><img src="https://cdn.allegorithmic.com/images/academy/f155be69-8480-4070-9e05-cb266051d19f" alt></p><p><strong>金属度贴图类似于一张mask，它告诉shader如何处理基础色(base color)中的信息</strong></p><h3 id="金属度-Metallic-Grayscale-Linear"><a href="#金属度-Metallic-Grayscale-Linear" class="headerlink" title="金属度 Metallic (Grayscale - Linear)"></a>金属度 Metallic (Grayscale - Linear)</h3><p>金属贴图用于定义哪些区域是纯金属。作为一张灰度图，它的作用类似于一张mask，告知shader如何处理基础色(base color)中的信息。</p><p><img src="https://cdn.allegorithmic.com/images/academy/08294dc6-f38d-4cd6-af7f-fca8e9c00dda" alt></p><p>金属度贴图中的信息并不直接包含真实世界中的信息。它只是告知shader，基础色的哪些区域应当被作为漫反射颜色(绝缘体)，哪些区域应当被当作金属反射值。在金属度贴图中，0.0 (black – 0 sRGB) 表示非金属，而 1.0 (white – 255 sRGB) 代表纯金属。在实际操作中，当shader发现金属度贴图上的值是白色，它就将Base color贴图上相应的部分当作金属反射值来使用。</p><h4 id="制作准则-1"><a href="#制作准则-1" class="headerlink" title="制作准则"></a><em>制作准则</em></h4><p>金属表面有两个与贴图相关的方面：</p><ul><li>第一，它们的反射值很高，在 70%-100% 范围；</li><li>第二，有些金属可以生锈。<br>我们讨论制作准则时会分别检视这两个方面。</li></ul><h5 id="纯金属"><a href="#纯金属" class="headerlink" title="纯金属"></a><em>纯金属</em></h5><p>大致上，我们定义金属度贴图上灰度值 <strong>235-255</strong> 的范围为<em>纯金属</em>，在这一区间的金属需要它的Base color有 70-100% 的反射值，或者说 180-255 sRGB。如下图。再次说明，这些数值来源于真实世界的测量数据。<br><img src="https://cdn.allegorithmic.com/images/academy/94624c56-0119-4a99-95c3-45b877aca57d" alt></p><h5 id="锈蚀或绝缘体"><a href="#锈蚀或绝缘体" class="headerlink" title="锈蚀或绝缘体"></a><em>锈蚀或绝缘体</em></h5><p>当你制作一个表面时，需要考虑该金属的氧化情况，或者其它环境因素如尘土及污垢。当一个喷漆的金属某些部分被刮坏或者掉漆了的时候，暴露的金属是纯金属（金属度贴图中为白色），喷漆表面是绝缘层（金属度贴图中为黑色），如下图。<br><img src="https://cdn.allegorithmic.com/images/academy/ec724b25-74e5-4c89-bbfb-e5e6edde440a" alt></p><p>金属度贴图可以体现金属及非金属之间的过渡状态（灰度）。如果金属度低于 235 sRGB 的时候你需要降低base color上的反射值。想想一个部分盖住金属的尘土层，如下图。尘土是绝缘体，如果你保留纯白的金属度，shader会将这些尘土在base color上的值用作金属的反射值。尘土的颜色远低于光滑金属所需要的70%-100%范围。通过降低尘土区域的金属度，你才能制作出合适的介于绝缘体和金属反射值之间的过渡。<br><img src="https://cdn.allegorithmic.com/images/academy/ef553e0e-adeb-4f8c-b471-5e778875bc74" alt></p><p>在Substance Designer中可以使用Material Color Blend节点制作尘土效果。</p><h3 id="粗糙度-Roughness-Grayscale-Linear"><a href="#粗糙度-Roughness-Grayscale-Linear" class="headerlink" title="粗糙度 Roughness (Grayscale - Linear)"></a>粗糙度 Roughness (Grayscale - Linear)</h3><p>粗糙度贴图描述物体因为表面不规则导致的光线散射，反射的方向是随机的。这改变了光的方向，但是光的总体强度是保持不变的。粗糙的表面有面积更大、更暗的高光。光滑的表面会使高光反射保持聚集，看起来更亮更强，虽然总体反光量是相同的。<br><img src="https://cdn.allegorithmic.com/images/academy/fbc09194-da18-4478-b119-cd0a84be4930" alt></p><p>粗糙度贴图是最具创作性的贴图，它允许美术在视觉上定义一个表面的特征。使我们可以创造性的讲述这个表面的情况。它的环境是怎样的？它被好好珍藏还是粗暴对待？它曾被暴露在某些情况下吗？一个物体表面的情况可以告诉我们很多关于它所在的环境的故事，并因此与我们想要设计的这个物体，以及想要创造的整体世界相联系起来。</p><h4 id="制作准则-2"><a href="#制作准则-2" class="headerlink" title="制作准则"></a><em>制作准则</em></h4><p>保持创造性，讲述一个关于该表面的故事。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- ![](https://cdn.allegorithmic.com/images/academy/02bad626-27f5-4606-9908-473d67f816b8) --&gt;
&lt;h2 id=&quot;Metal-Roughness-Workflow-总结&quot;&gt;&lt;a href=&quot;#Metal-Roughness-Workflow-总结&quot; class=&quot;headerlink&quot; title=&quot;Metal / Roughness Workflow 总结&quot;&gt;&lt;/a&gt;Metal / Roughness Workflow 总结&lt;/h2&gt;&lt;h4 id=&quot;纯金属-Metallic-gt-235&quot;&gt;&lt;a href=&quot;#纯金属-Metallic-gt-235&quot; class=&quot;headerlink&quot; title=&quot;纯金属  (Metallic &amp;gt; 235)&quot;&gt;&lt;/a&gt;纯金属  (Metallic &amp;gt; 235)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;BaseColor上的值是金属的反射值，应当有 70-100%，或者说 180-255 sRGB&lt;/li&gt;
&lt;li&gt;如果你得到某个金属素材，发现它的Base Color很黑，它可能是Specular/Glossiness工作流&lt;br&gt;hexo&lt;h4 id=&quot;介电质-绝缘体：&quot;&gt;&lt;a href=&quot;#介电质-绝缘体：&quot; class=&quot;headerlink&quot; title=&quot;介电质/绝缘体：&quot;&gt;&lt;/a&gt;介电质/绝缘体：&lt;/h4&gt;&lt;/li&gt;
&lt;li&gt;BaseColor暗部&lt;strong&gt;不应低于30-50 sRGB&lt;/strong&gt;, 亮部&lt;strong&gt;不应高于 240 sRGB&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;符合PBR规则可以使素材&lt;strong&gt;在任何光照条件下都有合理的表现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意,不等于不符合规则的贴图一定看起来不好（在特定光照下有可能看起也合理）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据以上原则，制作一个批量排查工具&lt;br&gt;&lt;img src=&quot;/img/graphics/pbrCheck.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Graphics" scheme="/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>阴影代理 (Shadow Proxy)</title>
    <link href="/2019/07/27/20190727-ShadowProxy/"/>
    <id>/2019/07/27/20190727-ShadowProxy/</id>
    <published>2019-07-26T16:00:00.000Z</published>
    <updated>2019-10-20T09:04:39.108Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/graphics/ShadowProxyComarison.jpg" alt></p><p><a href="https://docs.cryengine.com/display/CEMANUAL/Shadow+Proxies" target="_blank" rel="noopener">CryEngine: Shadow Proxy</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/graphics/ShadowProxyComarison.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.cryengine.com/display/CEMANUAL/Shadow+Proxies&quot; target
      
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Graphics" scheme="/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>植被制作流程 Vegetation and SpeedTree</title>
    <link href="/2019/07/06/20190706-Vegetation_SpeedTree/"/>
    <id>/2019/07/06/20190706-Vegetation_SpeedTree/</id>
    <published>2019-07-05T16:00:00.000Z</published>
    <updated>2020-08-02T08:41:50.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Cluster流程（Horizon-与-Farcry-的流程）"><a href="#Cluster流程（Horizon-与-Farcry-的流程）" class="headerlink" title="Cluster流程（Horizon 与 Farcry 的流程）"></a>Cluster流程（Horizon 与 Farcry 的流程）</h3><p><img src="/img/ta/vegetation_horizon_process00.jpg" alt></p><a id="more"></a><p><img src="/img/ta/vegetation_horizon_process01.jpg" alt><br><img src="/img/ta/vegetation_horizon_process_.jpg" alt><br><img src="/img/ta/vegetation_horizon.jpg" alt></p><h3 id="将项目中的树变更为Cluster流程"><a href="#将项目中的树变更为Cluster流程" class="headerlink" title="将项目中的树变更为Cluster流程"></a>将项目中的树变更为Cluster流程</h3><p><img src="/img/ta/vegetation_cluster.jpg" alt></p><ul><li>好处是，制作周期和修改周期都大幅缩短（LOD），视觉效果更好，总体性能更好</li><li>缺点是，面数更高</li></ul><p><img src="/img/ta/vegetation_cluster_procon.jpg" alt></p><p>项目植被变更为Cluster流程后：<br>制作和修改周期缩短为Card流程的五分之一，<br>运行时性能开销下降约15%，<br>美术表现有较大提升。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Jim Thacker, <a href="https://www.gnomon.edu/blog/discover-naughty-dog-s-environment-art-workflow-for-uncharted-4" target="_blank" rel="noopener">Discover Uncharted 4’s Environment Art Workflow</a> ,2016<br>Nils Arenz, <a href="https://medium.com/@EightyLevel/preparing-realistic-grass-in-ue4-8bf54b1fa01c" target="_blank" rel="noopener">Preparing Realistic Grass in UE4</a>，2018<br>Jobye Karmaker, <a href="https://80.lv/articles/vegetation-creation-for-video-games/" target="_blank" rel="noopener">Vegetation Creation for Video Games</a>, 2016<br>Adrian Courrèges, <a href="http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/" target="_blank" rel="noopener">GTA V - Graphics Study</a>, 2015<br>Danny Weinbaum, <a href="https://www.gamasutra.com/blogs/DannyWeinbaum/20171201/310813/Foliage_Optimization_in_Unity.php" target="_blank" rel="noopener">Foliage Optimization in Unity</a>, 2017<br>MoonChildInSky, <a href="https://zhuanlan.zhihu.com/p/39627412?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=686175245690474496" target="_blank" rel="noopener">《幽灵行动：荒野》地形技术和工具</a>, GDC 2017<br>Johan Andersson, Terrain Rendering in Frostbite Using Procedural Shader Splatting, SIGGRAPH 2007<br>Jaap van Muijden, GPU-based Procedural Placement in Horizon Zero Dawn, GDC 2017<br>, <a href="https://www.eurogamer.net/articles/digitalfoundry-2017-horizon-zero-dawn-the-making-of-ps4-pros-best-4k-game" target="_blank" rel="noopener">Horizon Zero Dawn: the making of PS4 Pro’s best 4K game Guerrilla Games on how it met the ultra HD challenge</a>, 2017<br>Théophile Lebeau, <a href="https://80.lv/articles/creating-a-forest-biome-with-photogrammetry/" target="_blank" rel="noopener">Creating a Forest Biome with Photogrammetry</a>, 2018<br>Stephen McAuley, <a href="https://www.gdcvault.com/play/1022235/Rendering-the-World-of-Far" target="_blank" rel="noopener">Rendering of the world of Far Cry 4</a>, GDC 2015</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Cluster流程（Horizon-与-Farcry-的流程）&quot;&gt;&lt;a href=&quot;#Cluster流程（Horizon-与-Farcry-的流程）&quot; class=&quot;headerlink&quot; title=&quot;Cluster流程（Horizon 与 Farcry 的流程）&quot;&gt;&lt;/a&gt;Cluster流程（Horizon 与 Farcry 的流程）&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/img/ta/vegetation_horizon_process00.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Graphics" scheme="/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>CommandBuffer 描边</title>
    <link href="/2019/06/15/20190615-GlowOutline/"/>
    <id>/2019/06/15/20190615-GlowOutline/</id>
    <published>2019-06-14T16:00:00.000Z</published>
    <updated>2019-10-20T09:12:19.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/graphics/GlowOutlineCommandBuffer.png" alt></p><p>参考：<br><a href="http://xroft666.blogspot.com/2015/07/glow-highlighting-in-unity.html" target="_blank" rel="noopener">Glow highlighting in Unity</a><br><a href="https://blog.csdn.net/puppet_master/article/details/72669977" target="_blank" rel="noopener">Unity Shader-Command Buffer的使用（景深与描边效果重置版）</a></p><a id="more"></a><h3 id="Compare-Camera-Depth"><a href="#Compare-Camera-Depth" class="headerlink" title="Compare Camera Depth"></a>Compare Camera Depth</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sampler2D _CameraDepthTexture;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(UNITY_REVERSED_Z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPARE_DEPTH(a, b) step(b, a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPARE_DEPTH(a, b) step(a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// in vert</span></span><br><span class="line"></span><br><span class="line">o.projPos = ComputeScreenPos(o.pos);</span><br><span class="line">o.projPos.z = COMPUTE_DEPTH_01;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// in frag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> depth = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.projPos));</span><br><span class="line">depth = Linear01Depth(depth);=</span><br><span class="line"></span><br><span class="line">COMPARE_DEPTH(i.projPos.z, depth);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/graphics/GlowOutlineCommandBuffer.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;http://xroft666.blogspot.com/2015/07/glow-highlighting-in-unity.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Glow highlighting in Unity&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/puppet_master/article/details/72669977&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Unity Shader-Command Buffer的使用（景深与描边效果重置版）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Graphics" scheme="/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Fresnel</title>
    <link href="/2019/06/14/20190614-Fresnel/"/>
    <id>/2019/06/14/20190614-Fresnel/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2019-08-31T01:52:54.491Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Fresnel"><a href="#Fresnel" class="headerlink" title="Fresnel"></a>Fresnel</h3><p><img src="/img/graphics/EveryThingHasFresnel.jpg" alt></p><h2 id="Example-Water-Fresnel"><a href="#Example-Water-Fresnel" class="headerlink" title="Example Water Fresnel"></a>Example Water Fresnel</h2><p><img src="/img/graphics/waterFresnel.png" alt></p><p><img src="/img/graphics/fresnelOnly.jpg" alt></p><a id="more"></a><!--![](/img/graphics/waterFresnelComparison.jpg)-->]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Fresnel&quot;&gt;&lt;a href=&quot;#Fresnel&quot; class=&quot;headerlink&quot; title=&quot;Fresnel&quot;&gt;&lt;/a&gt;Fresnel&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/img/graphics/EveryThingHasFresnel.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;Example-Water-Fresnel&quot;&gt;&lt;a href=&quot;#Example-Water-Fresnel&quot; class=&quot;headerlink&quot; title=&quot;Example Water Fresnel&quot;&gt;&lt;/a&gt;Example Water Fresnel&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/graphics/waterFresnel.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/graphics/fresnelOnly.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Graphics" scheme="/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>光照探针(LightProbe) 与 球谐(Spherical Harmonics)</title>
    <link href="/2019/06/01/20190601-SphericalHarmonics/"/>
    <id>/2019/06/01/20190601-SphericalHarmonics/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-10-20T09:00:10.572Z</updated>
    
    <content type="html"><![CDATA[<p>需求：可以手动自定义，并且随Prefab保存的LightProbe</p><h4 id="球谐函数-Spherical-Harmonics"><a href="#球谐函数-Spherical-Harmonics" class="headerlink" title="球谐函数 (Spherical Harmonics)"></a>球谐函数 (Spherical Harmonics)</h4><p><img src="/img/graphics/Spherical_Harmonics.jpg" alt></p><p>正经定义：<br>球谐函数是拉普拉斯方程的球坐标系形式解的角度部分</p><p>自分白话解释：<br>球谐函数 - 使用少量系数定义一个球面的整个表面：输入一个方向(球面上一点)，输出该方向的颜色</p><p>Unity中使用的是二阶球谐函数 <a href="https://docs.unity3d.com/ScriptReference/Rendering.SphericalHarmonicsL2.html" target="_blank" rel="noopener">SphericalHarmonicsL2</a>，保存为9个系数(27个float)，使用时转换为7个Vector4提供给Shader(参考buitin shaders中的ShadeSH9)</p><p>Unity的实现参考的是 <a href="http://www.ppsloan.org/publications/StupidSH36.pdf" target="_blank" rel="noopener">Stupid Spherical Harmonics (SH) Tricks</a></p><p>官方文档中关于光照探针的技术信息： <a href="https://docs.unity3d.com/Manual/LightProbes-TechnicalInformation.html" target="_blank" rel="noopener">Light Probes: Technical information</a></p><p>关于SH一篇非常好的文章： <a href="https://patapom.com/blog/SHPortal/" target="_blank" rel="noopener">Benoît Mayaux (Patapom), Spherical Harmonics</a></p><p>还有企鹅学院的两篇：<br>(Unity Shader球谐光照解析)[<a href="https://gameinstitute.qq.com/community/detail/124147]" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/124147]</a><br>(球谐光照（spherical harmonic lighting）解析)[<a href="https://gameinstitute.qq.com/community/detail/123183]" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/123183]</a></p><h4 id="自动布置LightProbe"><a href="#自动布置LightProbe" class="headerlink" title="自动布置LightProbe"></a>自动布置LightProbe</h4><p>将需要LightProbe的位置赋值给 <a href="https://docs.unity3d.com/ScriptReference/LightProbeGroup-probePositions.html" target="_blank" rel="noopener">LightProbeGroup.probePositions</a></p><p>官方例子：<a href="https://docs.unity3d.com/Manual/LightProbes-Placing-Scripting.html" target="_blank" rel="noopener">Placing probes using scripting</a></p><h4 id="Unity中手动计算SH"><a href="#Unity中手动计算SH" class="headerlink" title="Unity中手动计算SH"></a>Unity中手动计算SH</h4><p><img src="/img/graphics/mlpDemo.jpg" alt></p><p>SphericalHarmonicsL2提供两个方法</p><ul><li>添加环境光(AddAmbientLight)</li><li>添加平行光(AddDirectionalLight)</li></ul><p>Unity官方文档提供了一个例子：[LightProbes.bakedProbes(Unity文档)]<a href="https://docs.unity3d.com/ScriptReference/LightProbes-bakedProbes.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/LightProbes-bakedProbes.html</a></p><a id="more"></a><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Color m_Ambient;</span><br><span class="line">    <span class="keyword">public</span> Light[] m_Lights;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// On start add the contribution of the ambient light and all lights</span></span><br><span class="line">    <span class="comment">// assigned to the lights array to all baked probes.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SphericalHarmonicsL2[] bakedProbes = LightmapSettings.lightProbes.bakedProbes;</span><br><span class="line">        Vector3[] probePositions = LightmapSettings.lightProbes.positions;</span><br><span class="line">        <span class="keyword">int</span> probeCount = LightmapSettings.lightProbes.count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clear all probes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; probeCount; i++)</span><br><span class="line">            bakedProbes[i].Clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add ambient light to all probes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; probeCount; i++)</span><br><span class="line">            bakedProbes[i].AddAmbientLight(m_Ambient);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add directional and point lights' contribution to all probes</span></span><br><span class="line">        <span class="keyword">foreach</span> (Light l <span class="keyword">in</span> m_Lights)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l.type == LightType.Directional)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; probeCount; i++)</span><br><span class="line">                    bakedProbes[i].AddDirectionalLight(-l.transform.forward, l.color, l.intensity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l.type == LightType.Point)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; probeCount; i++)</span><br><span class="line">                    SHAddPointLight(probePositions[i], l.transform.position, l.range, l.color, l.intensity, <span class="keyword">ref</span> bakedProbes[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LightmapSettings.lightProbes.bakedProbes = bakedProbes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SHAddPointLight</span>(<span class="params">Vector3 probePosition, Vector3 position, <span class="keyword">float</span> range, Color color, <span class="keyword">float</span> intensity, <span class="keyword">ref</span> SphericalHarmonicsL2 sh</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// From the point of view of an SH probe, point light looks no different than a directional light,</span></span><br><span class="line">        <span class="comment">// just attenuated and coming from the right direction.</span></span><br><span class="line">        Vector3 probeToLight = position - probePosition;</span><br><span class="line">        <span class="keyword">float</span> attenuation = <span class="number">1.0F</span> / (<span class="number">1.0F</span> + <span class="number">25.0F</span> * probeToLight.sqrMagnitude / (range * range));</span><br><span class="line">        sh.AddDirectionalLight(probeToLight.normalized, color, intensity * attenuation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在已有LightProbe烘焙的环境中的指定位置获取LightProbe"><a href="#在已有LightProbe烘焙的环境中的指定位置获取LightProbe" class="headerlink" title="在已有LightProbe烘焙的环境中的指定位置获取LightProbe"></a>在已有LightProbe烘焙的环境中的指定位置获取LightProbe</h4><p>使用方法<a href="https://docs.unity3d.com/ScriptReference/LightProbes.GetInterpolatedProbe.html" target="_blank" rel="noopener">LightProbes.GetInterpolatedProbe</a></p><h4 id="LightProbe的SH差值"><a href="#LightProbe的SH差值" class="headerlink" title="LightProbe的SH差值"></a>LightProbe的SH差值</h4><p><img src="/img/graphics/Light-Probe-Interpolation-Using-Tetrahedral.png" alt><br>Unity官方在GDC 2012上的说明, <a href="https://www.gdcvault.com/play/1015312/Light-Probe-Interpolation-Using-Tetrahedral" target="_blank" rel="noopener">Light Probe Interpolation Using Tetrahedral Tessellations</a></p><p>Unity中烘焙时计算四面体网络(TetrahedronGrid)并保存，运行时根据对象在某个四面体中的位置，利用这个四面体相关的几个SH插值出一个新的SH</p><p>更多阅读:<br><a href="https://arxiv.org/abs/physics/0206007" target="_blank" rel="noopener">Spherical Harmonics Interpolation, Computation of Laplacians and Gauge Theory</a></p><h4 id="将SH系数注入Renderer"><a href="#将SH系数注入Renderer" class="headerlink" title="将SH系数注入Renderer"></a>将SH系数注入Renderer</h4><p>Unity官方的Keijiro Takahashi 写的 <a href="https://github.com/keijiro/LightProbeUtility" target="_blank" rel="noopener">LightProbeUtility</a></p><p><img src="https://camo.githubusercontent.com/bfda9b5c1438318d429440db42f88464b6214037/68747470733a2f2f34352e6d656469612e74756d626c722e636f6d2f66373934666138383130613932313463326434303065653761346162623132642f74756d626c725f6f34326f7a69614d475a3171696f3436396f315f3430302e676966" alt></p><p>注意系数的组合方式在之后的版本中有变化，正确的组合如下</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constant + Linear</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    properties.SetVector(_idSHA[i], <span class="keyword">new</span> Vector4(</span><br><span class="line">        sh[i, <span class="number">3</span>], sh[i, <span class="number">1</span>], sh[i, <span class="number">2</span>], sh[i, <span class="number">0</span>] - sh[i, <span class="number">6</span>] </span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quadratic polynomials</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    properties.SetVector(_idSHB[i], <span class="keyword">new</span> Vector4(</span><br><span class="line">        sh[i, <span class="number">4</span>], sh[i, <span class="number">5</span>], sh[i, <span class="number">6</span>] * <span class="number">3</span>, sh[i, <span class="number">7</span>]</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Final quadratic polynomial</span></span><br><span class="line">properties.SetVector(_idSHC, <span class="keyword">new</span> Vector4(</span><br><span class="line">    sh[<span class="number">0</span>, <span class="number">8</span>], sh[<span class="number">1</span>, <span class="number">8</span>], sh[<span class="number">2</span>, <span class="number">8</span>], <span class="number">1</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>UnityCG.cginc中相关的代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal should be normalized, w=1.0</span></span><br><span class="line"><span class="function">half3 <span class="title">SHEvalLinearL0L1</span> (<span class="params">half4 normal</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half3 x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Linear (L1) + constant (L0) polynomial terms</span></span><br><span class="line">    x.r = dot(unity_SHAr,normal);</span><br><span class="line">    x.g = dot(unity_SHAg,normal);</span><br><span class="line">    x.b = dot(unity_SHAb,normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// normal should be normalized, w=1.0</span></span><br><span class="line"><span class="function">half3 <span class="title">SHEvalLinearL2</span> (<span class="params">half4 normal</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    half3 x1, x2;</span><br><span class="line">    <span class="comment">// 4 of the quadratic (L2) polynomials</span></span><br><span class="line">    half4 vB = normal.xyzz * normal.yzzx;</span><br><span class="line">    x1.r = dot(unity_SHBr,vB);</span><br><span class="line">    x1.g = dot(unity_SHBg,vB);</span><br><span class="line">    x1.b = dot(unity_SHBb,vB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Final (5th) quadratic (L2) polynomial</span></span><br><span class="line">    half vC = normal.x*normal.x - normal.y*normal.y;</span><br><span class="line">    x2 = unity_SHC.rgb * vC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x1 + x2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// normal should be normalized, w=1.0</span></span><br><span class="line"><span class="comment">// output in active color space</span></span><br><span class="line"><span class="function">half3 <span class="title">ShadeSH9</span> (<span class="params">half4 normal</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Linear + constant polynomial terms</span></span><br><span class="line">    half3 res = SHEvalLinearL0L1 (normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Quadratic polynomials</span></span><br><span class="line">    res += SHEvalLinearL2 (normal);</span><br><span class="line"></span><br><span class="line"><span class="meta">#   ifdef UNITY_COLORSPACE_GAMMA</span></span><br><span class="line">        res = LinearToGammaSpace (res);</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需求：可以手动自定义，并且随Prefab保存的LightProbe&lt;/p&gt;
&lt;h4 id=&quot;球谐函数-Spherical-Harmonics&quot;&gt;&lt;a href=&quot;#球谐函数-Spherical-Harmonics&quot; class=&quot;headerlink&quot; title=&quot;球谐函数 (Spherical Harmonics)&quot;&gt;&lt;/a&gt;球谐函数 (Spherical Harmonics)&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/img/graphics/Spherical_Harmonics.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;正经定义：&lt;br&gt;球谐函数是拉普拉斯方程的球坐标系形式解的角度部分&lt;/p&gt;
&lt;p&gt;自分白话解释：&lt;br&gt;球谐函数 - 使用少量系数定义一个球面的整个表面：输入一个方向(球面上一点)，输出该方向的颜色&lt;/p&gt;
&lt;p&gt;Unity中使用的是二阶球谐函数 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Rendering.SphericalHarmonicsL2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SphericalHarmonicsL2&lt;/a&gt;，保存为9个系数(27个float)，使用时转换为7个Vector4提供给Shader(参考buitin shaders中的ShadeSH9)&lt;/p&gt;
&lt;p&gt;Unity的实现参考的是 &lt;a href=&quot;http://www.ppsloan.org/publications/StupidSH36.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Stupid Spherical Harmonics (SH) Tricks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方文档中关于光照探针的技术信息： &lt;a href=&quot;https://docs.unity3d.com/Manual/LightProbes-TechnicalInformation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Light Probes: Technical information&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于SH一篇非常好的文章： &lt;a href=&quot;https://patapom.com/blog/SHPortal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Benoît Mayaux (Patapom), Spherical Harmonics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有企鹅学院的两篇：&lt;br&gt;(Unity Shader球谐光照解析)[&lt;a href=&quot;https://gameinstitute.qq.com/community/detail/124147]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gameinstitute.qq.com/community/detail/124147]&lt;/a&gt;&lt;br&gt;(球谐光照（spherical harmonic lighting）解析)[&lt;a href=&quot;https://gameinstitute.qq.com/community/detail/123183]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gameinstitute.qq.com/community/detail/123183]&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;自动布置LightProbe&quot;&gt;&lt;a href=&quot;#自动布置LightProbe&quot; class=&quot;headerlink&quot; title=&quot;自动布置LightProbe&quot;&gt;&lt;/a&gt;自动布置LightProbe&lt;/h4&gt;&lt;p&gt;将需要LightProbe的位置赋值给 &lt;a href=&quot;https://docs.unity3d.com/ScriptReference/LightProbeGroup-probePositions.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LightProbeGroup.probePositions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方例子：&lt;a href=&quot;https://docs.unity3d.com/Manual/LightProbes-Placing-Scripting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Placing probes using scripting&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Unity中手动计算SH&quot;&gt;&lt;a href=&quot;#Unity中手动计算SH&quot; class=&quot;headerlink&quot; title=&quot;Unity中手动计算SH&quot;&gt;&lt;/a&gt;Unity中手动计算SH&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/img/graphics/mlpDemo.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;SphericalHarmonicsL2提供两个方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加环境光(AddAmbientLight)&lt;/li&gt;
&lt;li&gt;添加平行光(AddDirectionalLight)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unity官方文档提供了一个例子：[LightProbes.bakedProbes(Unity文档)]&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/LightProbes-bakedProbes.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.unity3d.com/ScriptReference/LightProbes-bakedProbes.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="Graphics" scheme="/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>收拾东西翻出一套搁置脑洞 (Animal Boxing)</title>
    <link href="/2019/01/12/20190112-animalBoxing/"/>
    <id>/2019/01/12/20190112-animalBoxing/</id>
    <published>2019-01-11T16:00:00.000Z</published>
    <updated>2019-05-31T02:20:59.392Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/animalboxing/mmexport1547290455260.png" alt></p><a id="more"></a><p><img src="/img/animalboxing/mmexport1547290462270.jpg" alt><br><img src="/img/animalboxing/mmexport1547290464170.png" alt><br><img src="/img/animalboxing/mmexport1547290452146.png" alt><br><img src="/img/animalboxing/mmexport1547290457071.jpg" alt><br><img src="/img/animalboxing/mmexport1547290458742.jpg" alt><br><img src="/img/animalboxing/mmexport1547290460442.jpg" alt><br><img src="/img/animalboxing/mmexport1547290444647.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/animalboxing/mmexport1547290455260.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Dev" scheme="/tags/Game-Dev/"/>
    
      <category term="画" scheme="/tags/%E7%94%BB/"/>
    
      <category term="脑洞" scheme="/tags/%E8%84%91%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>阿西达卡与卡雅</title>
    <link href="/2018/12/14/20181214-Axidaka_Kaya/"/>
    <id>/2018/12/14/20181214-Axidaka_Kaya/</id>
    <published>2018-12-13T16:00:00.000Z</published>
    <updated>2019-05-31T02:20:59.392Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/drawings/mmexport1547466623253.jpg" alt></p><a id="more"></a><p><img src="/img/drawings/mmexport1547466610392.jpg" alt><br><img src="/img/drawings/mmexport1547466613324.jpg" alt><br><img src="/img/drawings/mmexport1547466615951.jpg" alt><br><img src="/img/drawings/mmexport1547466618417.jpg" alt></p><p><img src="/img/drawings/mmexport1547466631567.jpg" alt><br><img src="/img/drawings/mmexport1547466634061.jpg" alt><br><img src="/img/drawings/mmexport1547466626616.jpg" alt><br><img src="/img/drawings/mmexport1547466629138.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/drawings/mmexport1547466623253.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="画" scheme="/tags/%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>练习</title>
    <link href="/2018/10/26/20181026-Lianxi/"/>
    <id>/2018/10/26/20181026-Lianxi/</id>
    <published>2018-10-25T16:00:00.000Z</published>
    <updated>2019-05-31T02:20:59.391Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/drawings/mmexport1547465582079.jpg" alt></p><a id="more"></a><p><img src="/img/drawings/mmexport1547465587685.jpg" alt></p><p><img src="/img/drawings/mmexport1547465585073.jpg" alt><br><img src="/img/drawings/mmexport1547465590268.jpg" alt></p><p><img src="/img/drawings/mmexport1547465592921.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/drawings/mmexport1547465582079.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="画" scheme="/tags/%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>青海</title>
    <link href="/2018/09/10/20180910-Qinghai/"/>
    <id>/2018/09/10/20180910-Qinghai/</id>
    <published>2018-09-09T16:00:00.000Z</published>
    <updated>2019-05-31T02:20:59.391Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/drawings/mmexport1547465601926.jpg" alt><br><img src="/img/drawings/mmexport1547465611142.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/drawings/mmexport1547465601926.jpg&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;/img/drawings/mmexport1547465611142.jpg&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="照片" scheme="/tags/%E7%85%A7%E7%89%87/"/>
    
  </entry>
  
</feed>
